1.为了满足不同的计算与存储需要
2.  short a = 80; unsigned int b = 42110; long a = 3000000000; //更正 应为 long long a=3000000000；
    //备注：
    //int is 4 bytes.
    //short is 2 bytes.
    //long long is 8 bytes.

    //Maximum values:
    //int: 2147483647
    //short: 32767
    //long: 2147483647
    //long long: 9223372036854775807

    //Minimum int value = -2147483648

3.溢出后循环赋值 //更正：C++没有提供自动方之超出整形限制的功能，可以使用头文件climits来确定限制情况
4.33被存储为const int,而33L被存储为const long
5.等价  //更正：不等价，首先，只有使用ASCII美国信息交换标准代码的系统上，65才对应A，其次，65是const int,而'A'是const char
6.法一：char a=88; cout << a;
  法二：cout<< char(88);
  //备注:还有 cout.put(cahr(88)); cout << (char)88;
7.
- short 至少16位； 
- int 至少和short一样长； 
- long 至少32位，且至少和int一样长； 
- long long 至少64位，且至少和long一样长。 
- 一般double为64位
故将long, long long值赋给double变量时，均有可能导致舍入误差；
//参考答案：取决于类型的长度，如果long为4字节，则没有损失，此时最大的long将是20亿（10位数），double提供了至少13位有效数字，因而不需要进行任何舍入，long long可提供19位有效数字，超过了double保证的13位有效数字
8.
a-74 b-4 c-0 d-4.5 e-3
9. int_result=(int)double_a +(int)double_b;
   int_result= double_a + double_b;
10. int;float;char;char32_t;float // 更正：最后一个应该为double